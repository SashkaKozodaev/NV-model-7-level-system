# -*- coding: utf-8 -*-
"""7LS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nPmMM_HexermtwGtnNeHXHKhJFrTf6FW
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install qutip
# !pip install tqdm

from qutip import *
from qutip import Qobj, Options, mesolve
import qutip as q
import numpy as np
import scipy
from scipy.integrate import cumulative_trapezoid as cumtrapz
from scipy.optimize import curve_fit
from numpy import pi, exp, sqrt, linspace, zeros, logspace, sin, cos, array, tan
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from tqdm import tqdm

#@title Характерные времена
norm = 1e6

T_3E_life_time = 13*1e-9 *norm  # 13нс
T_1E_life_time = 170*1e-9 *norm# 170нс
T2_star =        0.4*1e-6 *norm# 0.4мкс
T1 =             5*1e-3 *norm  # 5мс

pi2 = 2 * pi

#@title Скорости

G_T1 = 1./T1 *pi2
G_T2_star = 1./T2_star
G_T_1E = 1./T_1E_life_time *pi2
G_T_3E = 1./T_3E_life_time *pi2

# Define the states: |0>, |-1>, |+1>, |e0>, |e-1>, |e+1>, |s>
N = 7
ground_states = [basis(N, i) for i in range(N)]

#@title H(ΩR, Δ - detune) -> Qobg(H)

def H(Omega_R, Delta=0):
  H = Delta * pi2 * (ground_states[1] * ground_states[1].dag() + ground_states[2] * ground_states[2].dag())
  H = H + Omega_R/2 * pi2 * (ground_states[0] * ground_states[1].dag() + ground_states[1] * ground_states[0].dag())
                      # + ground_states[0] * ground_states[2].dag() + ground_states[2] * ground_states[0].dag())

  return H

#@title H_mod(ΩR, Ωm, deep, Delta) -> Qobg(H_modulate), dict(args)

def H_mod(Omega_R, Ωm, d=0, Delta=0):
  H0 = H(Omega_R, Delta)
  H1 = d * pi2 * (ground_states[1] * ground_states[1].dag() )

  args = {'Wm': Ωm * pi2}
  H_modulate = [H0, [H1, 'cos(Wm * t)']]

  return H_modulate, args

#@title create_operator(index_to, index_from, g = 1) -> Qobj(L)

def create_operator(index_to, index_from, g = 1):
  L = sqrt(g) * ground_states[index_to] * ground_states[index_from].dag()
  return L

"""$$\frac{d}{dt}p_0 = -2\gamma p_0 + \gamma p_{-1} + \gamma p_{p+1}$$
$$\frac{d}{dt}p_{-1} = -\gamma p_{-1} + \gamma p_{0}$$
$$\frac{d}{dt}p_{+1} = - \gamma p_{+1} + \gamma p_{0}$$

$$p_0 + p_{-1} + p_{+1} = 1$$

$$\frac{d}{dt}p_0 = -2\gamma p_0 + \gamma (1-p_0)$$

$$\frac{d}{dt}p_0 + 3\gamma p_0= \gamma$$

$$p_0(t) = (p_0(0) - \frac{1}{3})  exp(-3\gamma t) + \frac{1}{3}$$
"""

#@title collaps_operators(s_parametr) -> list(c_ops)

def collaps_operators(s):

  # T1 relaxation (|-1><0|, |0><-1|, |+1><0|, |0><+1|)
  L_T1_1 = create_operator(0, 1, G_T1/3)
  L_T1_2 = create_operator(1, 0, G_T1/3)
  L_T1_3 = create_operator(0, 2, G_T1/3)
  L_T1_4 = create_operator(2, 0, G_T1/3)

  # Optical pumping (|e0><0|, |e-1><-1|, |+1><e+1|)
  L_opt_1 = create_operator(3, 0, G_T_3E * s)
  L_opt_2 = create_operator(4, 1, G_T_3E * s)
  L_opt_3 = create_operator(5, 2, G_T_3E * s)

  # Decay from excited states (|0><e0|, |-1><e-1|, |+1><e+1|)
  L_decay_1 = create_operator(0, 3, G_T_3E)
  L_decay_2 = create_operator(1, 4, G_T_3E * 0.7)
  L_decay_3 = create_operator(2, 5, G_T_3E * 0.7)

  # Decay from |e-1>,|e+1> to |s>
  L_e1_s_1 = create_operator(6, 4, G_T_3E * 0.3)
  L_e1_s_2 = create_operator(6, 5, G_T_3E * 0.3)

  # Decay from |s> to ground states (equal probability)
  L_s_g0 = create_operator(0, 6, G_T_1E * 0.8)
  L_s_gm1 = create_operator(1, 6, G_T_1E * 0.1)
  L_s_gp1 = create_operator(2, 6, G_T_1E * 0.1)

  # Dephasing (|0><0| - |1><1|)
  L_T2_star_1 = np.sqrt(G_T2_star/3) * (ground_states[0] * ground_states[0].dag() -
                                  ground_states[1] * ground_states[1].dag())

  L_T2_star_2 = np.sqrt(G_T2_star/3) * (ground_states[0] * ground_states[0].dag() -
                                  ground_states[2] * ground_states[2].dag())

  L_T2_star_3 = np.sqrt(G_T2_star/3) * (ground_states[1] * ground_states[1].dag() -
                                  ground_states[2] * ground_states[2].dag())

  c_ops = [L_T1_1, L_T1_2, L_T1_3, L_T1_4,
           L_opt_1, L_opt_2, L_opt_3,
           L_decay_1, L_decay_2, L_decay_3,
           L_e1_s_1, L_e1_s_2,
           L_s_g0, L_s_gm1, L_s_gp1,
           L_T2_star_1, L_T2_star_2, L_T2_star_3]

  return c_ops

#@title Get_equilibrium(level, ΩR, s_parametr, Δ=0) -> int(population)

def Get_equilibrium(level_name, ΩR, s, Delta=0):

    c_ops = collaps_operators(s)

    rho = q.steadystate(H(ΩR, Delta), c_ops)

    level_index = {'0': 0, '-1': 1, '+1': 2, 'e0': 3, 'e-1': 4, 'e+1': 5, 's': 6}[level_name]
    population = rho[level_index, level_index].real

    return population

"""![image.png](data:image/png;base64,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)

# Населённость от ΩR и от s-параметра
"""

level = '0'  # Can be '0', '-1', '+1', 'e0', 'e-1', 'e+1', 's'

ΩR = 1
s = 0# 1e-3
population = Get_equilibrium(level, ΩR, s)
print(f"Населённость уровня |{level}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ",population)

level = '0'
s = 0.01
ΩR_mas = linspace(0.01*1e6, 1*1e6, 100)/norm
populations = []

for ΩR in ΩR_mas:
  populations.append(Get_equilibrium(level, ΩR, s))


plt.figure(figsize=(8, 4))
plt.plot(ΩR_mas, populations,  label = f'level {level}')
plt.xlabel('$\Omega_R$ [MHz]')
plt.ylabel(f'Population')
plt.legend()
plt.grid(True)
plt.show()

level = '0'
ΩR = 0.5 * 1e6/norm
s_mas = logspace(-7, 0, 100)

populations_MW = []
populations_no_MW = []

for s in s_mas:
  populations_MW.append(Get_equilibrium(level, ΩR, s))
  populations_no_MW.append(Get_equilibrium(level, 0, s))


plt.figure(figsize=(8, 4))
plt.plot(s_mas, populations_MW,  label = f'level |{level}> with MW, $\Omega_R$ = {ΩR} [MHz]')
plt.plot(s_mas, populations_no_MW,  label = f'level |{level}>')
plt.xlabel('s parametr')
plt.ylabel(f'Population')
plt.xscale('log')
plt.legend()
plt.grid(True)
plt.show()

"""# Contrast"""

plt.figure(figsize=(8, 4))
plt.plot(s_mas, (np.array(populations_no_MW) - np.array(populations_MW))/np.array(populations_no_MW),  label = f'level {level} with MW')
plt.xlabel('s parametr')
plt.ylabel(f'Попугаи, похожие на контраст')
plt.xscale('log')
plt.legend()
plt.grid(True)
plt.show()

level = '0'
ΩR = 0.5 * 1e6/norm
s_mas = logspace(-7, 0, 100)
ΩR_mas = [0.1, 0.5, 1, 2, 5, 7, 10]

plt.figure(figsize=(8, 4))

for ΩR in ΩR_mas:
  contrast_slice = []
  for s in s_mas:
    contrast_slice.append((Get_equilibrium('0', 0, s) - Get_equilibrium('0', ΩR, s)) * 0.075)
  plt.plot(s_mas, contrast_slice,  label = f'$\Omega_R$ = {ΩR} [MHz]')

plt.xlabel('s parametr')
plt.ylabel(f'Contrast')
plt.xscale('log')
plt.legend()
plt.grid(True)
plt.show()

ΩR_mas = np.linspace(0.1, 2, 200)
s_mas = np.logspace(-6, -1, 200)

contrast = np.zeros((len(s_mas), len(ΩR_mas)))

progress_bar = tqdm(total=len(ΩR_mas) * len(s_mas), desc="Общий прогресс цикла")

for i, s in enumerate(s_mas):
  for j, ΩR in enumerate(ΩR_mas):
    R1 = Get_equilibrium('0', ΩR, s)
    R0 = Get_equilibrium('0', 0, s)
    contrast[i,j] = (R0-R1) * 0.075

    progress_bar.update(1)

progress_bar.close()

plt.figure(figsize=(8, 6))
colors = ["blue", "cyan", "green", "yellow", "orange", "red"]
cmap = LinearSegmentedColormap.from_list("custom_cmap", colors)

plt.imshow(contrast,
           extent=[ΩR_mas.min(), ΩR_mas.max(), np.log10(s_mas.min()), np.log10(s_mas.max())],
           aspect='auto',
           origin='lower',
           cmap=cmap)

plt.colorbar()
plt.xlabel('ΩR, [MHz]', fontsize=12)
plt.ylabel('s parametr', fontsize=12)

ax = plt.gca()
y_ticks = np.arange(-6, 0)
ax.set_yticks(y_ticks)
ax.set_yticklabels([f"$10^{{{i}}}$" for i in y_ticks])

plt.title(f'contrast, %', fontsize=14)
plt.tight_layout()
plt.show()

"""#Lindblad(ΩR, Ωm, deep, time array, level, s_parametr,  Δ=0) -> list(p(t0), p(t1), ...)"""

#@title Lindblad(ΩR, Ωm, deep, time array, level, s_parametr,  Δ=0, rho_ini=q.basis(7, 0)) -> list(p(t0), p(t1), ...)
def Lindblad(Omega_R, Ωm, d, tlist, level, s, Delta=0, Prog_bar = True, rho_ini=q.basis(7, 0), level2 = "Nemo"):

  if level2 == "Nemo": level2=level

  H = H_mod(Omega_R, Ωm, d, Delta)[0]
  psi0 = Qobj(rho_ini)
  c_ops = collaps_operators(s)
  args = H_mod(Omega_R, Ωm, d, Delta)[1]

  level_index = {'0': 0, '-1': 1, '+1': 2, 'e0': 3, 'e-1': 4, 'e+1': 5, 's': 6}[level]
  level2_index = {'0': 0, '-1': 1, '+1': 2, 'e0': 3, 'e-1': 4, 'e+1': 5, 's': 6}[level2]

  if Prog_bar: options = {"nsteps": 1e6, "progress_bar": "tqdm"}
  else: options={"nsteps": 1e6}

  result = mesolve(H,
                  psi0,
                  tlist,
                  c_ops=c_ops,
                  e_ops=[create_operator(level_index, level2_index)],
                  args=args,
                  options=options
                  )

  return result.expect[0]

"""#Тесты, проверяем, что в модели всё работает корректно

## Проверка T1
"""

def collaps_operators(s):

  # T1 relaxation (|-1><0|, |0><-1|, |+1><0|, |0><+1|)
  L_T1_1 = create_operator(0, 1, G_T1/3)
  L_T1_2 = create_operator(1, 0, G_T1/3)
  L_T1_3 = create_operator(0, 2, G_T1/3)
  L_T1_4 = create_operator(2, 0, G_T1/3)


  c_ops = [L_T1_1, L_T1_2, L_T1_3, L_T1_4]

  return c_ops

from scipy.optimize import curve_fit

def exp_func(t, c1, c2, c3):
    return c1 + c2 * np.exp(-c3 * t)


level = '0'
ΩR = 0
Ωm = 0
deep = 0
s = 0
Δ = 0
tlist = np.linspace(0, 20000, 1001)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ)

p0 = [1/3, 2/3, 0.0002]
popt, pcov = curve_fit(exp_func, tlist, occupations, p0=p0)
c1, c2, c3 = popt

y_fit = exp_func(tlist, *popt)

#population = Get_equilibrium(level, ΩR, s)
print(f"Населённость уровня |{level}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ", round(population, 4))
print("Параметры фита:")
print(f"c1 = {c1:.4f}, c2 = {c2:.4f}, c3 = {c3:.8f}")

plt.figure(figsize=(8, 4))
plt.plot(tlist, occupations, label=f'level = |{level}> (данные)')
plt.plot(tlist, y_fit, 'r--', label=f'Фит: {c1:.3f} + {c2:.3f}*exp(-{c3:.4f}*t)')
plt.xlabel('time, мкс')
plt.ylabel('Population')
plt.legend()
plt.grid(True)
plt.show()

G_T1

level = '0'

ΩR = 0
Ωm = 0
deep = 0
s = 0
Δ = 0
tlist = linspace(0, 20000, 101)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ)


#population = Get_equilibrium(level, ΩR, s)
#print(f"Населённость уровня |{level}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ",round(population, 4))

#y = 1/3 + 2/3 * exp(-0.0006 * tlist)
y = 1/3 + 2/3 * exp(-G_T1 * tlist)

plt.figure(figsize=(8, 4))
plt.plot(tlist, occupations, label = f'level = |{level}>')
plt.plot(tlist, y, label = f"1/3 + 2/3*exp(-G_T1*t)")
plt.xlabel('time, мкс')
plt.ylabel(f'Population')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

level = '0'
ΩR = 0
Ωm = 0
deep = 0
s = 0
Δ = 0
tlist = np.linspace(0, 20000, 101)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ)
#population = Get_equilibrium(level, ΩR, s)

def exp_decay(t, A, gamma, C):
    return A * exp(-gamma * t) + C

# Начальные предположения для параметров
p0 = [2/3, G_T1, 1/3]  # A, γ, C

# Аппроксимируем данные
params, _ = curve_fit(exp_decay, tlist, occupations, p0=p0)
A_fit, gamma_fit, C_fit = params

y = exp_decay(tlist, A_fit, gamma_fit, C_fit)

plt.figure(figsize=(8, 4))
plt.plot(tlist, occupations, 'b-', label=f'Результат моделирования (|{level}⟩)')
plt.plot(tlist, y, 'r--', label=f'Экспоненциальная аппроксимация: {A_fit:.2f}exp(-{gamma_fit:.4f}t) + {C_fit:.2f}')
plt.xlabel('Время (мкс)', fontsize=12)
plt.ylabel('Населённость', fontsize=12)
plt.title(f'Релаксация уровня |{level}⟩ (T1 = {1/gamma_fit:.1f} мкс)', fontsize=14)
plt.legend(fontsize=10)
plt.grid(True)
plt.show()

print(f"Оценка T1 из аппроксимации: {1/(gamma_fit/pi2) :.1f} мкс")
print(f"Теоретическое значение T1: {T1:.1f} мкс")
#print(f"Равновесная населённость: {population:.4f}")

"""## Проверка T_3E_life_time"""

def collaps_operators(s):

  # Optical pumping (|e0><0|, |e-1><-1|, |+1><e+1|)
  L_opt_1 = create_operator(3, 0, G_T_3E * s)
  L_opt_2 = create_operator(4, 1, G_T_3E * s)
  L_opt_3 = create_operator(5, 2, G_T_3E * s)

  # Decay from excited states (|0><e0|, |-1><e-1|, |+1><e+1|)
  L_decay_1 = create_operator(0, 3, G_T_3E)
  L_decay_2 = create_operator(1, 4, G_T_3E * 0.7)
  L_decay_3 = create_operator(2, 5, G_T_3E * 0.7)

  # Decay from |e-1>,|e+1> to |s>
  L_e1_s_1 = create_operator(6, 4, G_T_3E * 0.3)
  L_e1_s_2 = create_operator(6, 5, G_T_3E * 0.3)



  c_ops = [
           L_opt_1, L_opt_1, L_opt_1,
           L_decay_1, L_decay_2, L_decay_3,
           L_e1_s_1, L_e1_s_2
           ]

  return c_ops

"""Здесь обращаю внимание, что мы в Lindblad явно указываем, что изначально вся населённость на |e0>, по дефолту, если не задать параметр rho_ini населённость на |0>"""

level = '0'

ΩR = 0.
Ωm = 0
deep = 0
s = 0.
Δ = 0
tlist = linspace(0, 5*T_3E_life_time, 101)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ, rho_ini=Qobj(create_operator(3, 3)))

y = 1 - exp(-G_T_3E * tlist)

plt.figure(figsize=(8, 4))
plt.plot(tlist, occupations, label = f'level = |{level}>')
plt.plot(tlist, y, label = f"1 - exp(-G_T_3E*t)")
plt.xlabel('time, мкс')
plt.ylabel(f'Population')
plt.legend()
plt.grid(True)
plt.show()

import scipy.optimize as opt
def exp_decay(t, A, gamma, C):
    return A * np.exp(-gamma * t) + C

level = 'e0'
ΩR = 0
Ωm = 0
deep = 0
s = 0.1
Δ = 0
tlist = np.linspace(0, 5*T_3E_life_time, 101)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ, rho_ini=Qobj(create_operator(3, 3)))


p0 = [0.5, G_T_3E, 0.5]  # A, γ, C

params, covariance = opt.curve_fit(exp_decay, tlist, occupations, p0=p0, maxfev=10000)
A_fit, gamma_fit, C_fit = params

T3E_fit = 1/(gamma_fit/pi2)

# Plotting
plt.figure(figsize=(8, 4))
plt.plot(tlist, occupations, 'b-', label=f'Simulation |{level}⟩')
plt.plot(tlist, exp_decay(tlist, A_fit, gamma_fit, C_fit), 'r--', label=f'Exponential Fit: {A_fit:.2f}exp(-{gamma_fit:.4f}t) + {C_fit:.2f}')
plt.xlabel('Time (s)', fontsize=12)
plt.ylabel('Population', fontsize=12)
plt.title(f'Relaxation of Level |{level}⟩ (T3E = {T3E_fit:.3f} s)', fontsize=14)
plt.legend(fontsize=10)
plt.grid(True)
plt.show()

print(f"T3E from fit: {T3E_fit:.5f} s")
print(f"Theoretical T3E: {T_3E_life_time:.3f} s")
#print(f"Equilibrium Population: {population_eq:.4f}")

from scipy.integrate import odeint

def equations(y, t):
    n0, nm1, np1, ne0, nem1, nep1, ns = y
    dn0dt = - s*G_T_3E * n0 + G_T_3E * ne0 + 0.8*G_T_1E * ns
    dnm1dt = - s*G_T_3E * nm1 + 0.7*G_T_3E * nem1 + 0.1*G_T_1E * ns
    dnp1dt = - s*G_T_3E * np1 + 0.7*G_T_3E * nep1 + 0.1*G_T_1E * ns
    dne0dt = s*G_T_3E * n0 - G_T_3E * ne0
    dnem1dt = s*G_T_3E * nm1 - G_T_3E * nem1
    dnep1dt = s*G_T_3E * np1 - G_T_3E * nep1
    dnsdt = 0.3*G_T_3E * nem1 + 0.3*G_T_3E * nep1 - G_T_1E * ns
    return [dn0dt, dnm1dt, dnp1dt, dne0dt, dnem1dt, dnep1dt, dnsdt]

y0 = [0, 0, 0, 1, 0, 0, 0]

t = np.linspace(0, 10*T_3E_life_time, 500)

sol = odeint(equations, y0, t)

# Извлечение населенности уровня |e0>
ne0 = sol[:, 3]

# Аппроксимация экспонентой
def exp_decay(t, A, gamma, C):
    return A * np.exp(-gamma * t) + C

p0 = [1, G_T_3E, 0] # Initial guesses
params, covariance = opt.curve_fit(exp_decay, t, ne0, p0=p0)
A_fit, gamma_fit, C_fit = params

# Эффективная скорость распада
effective_rate = gamma_fit
effective_T3E = 1/(effective_rate/pi2)

# Визуализация
plt.plot(t, ne0, label='ne0(t)')
plt.plot(t, exp_decay(t, A_fit, gamma_fit, C_fit), label='Exponential Fit')
plt.xlabel('Time (s)')
plt.ylabel('Population')
plt.legend()
plt.show()

print(f"Effective G_T3E: {effective_rate}")
print(f"Effective T3E: {effective_T3E}")

"""## Проверка T2_star"""

level = '0'

ΩR = 0.1
Ωm = 0
deep = 0
s = 0.0
Δ = 0.
tlist = linspace(0, T2_star, 101)

A = zeros((7, 7))
A[0][0], A[1][1], A[0][1], A[1][0] = 0.5, 0.5, 0.5, 0.5

p0 = Lindblad(ΩR, Ωm, deep, tlist, '0', s, Δ, rho_ini=A, level2='-1')

p0 = array(p0)


y = 0.5*exp(-1./T2_star * tlist)

plt.figure(figsize=(8, 4))
plt.plot(tlist, p0, label = f'level = |{level}>')
plt.plot(tlist, y, label = f"0.5*exp(-G_T2_star*t)")
plt.xlabel('time, мкс')
plt.ylabel(f'Population')
plt.legend()
plt.grid(True)
plt.show()

import scipy.optimize as opt
def exp_decay(t, A, gamma, C):
    return A * np.exp(-gamma * t) + C

level = '0'
ΩR = 0.1
Ωm = 0
deep = 0
s = 0.
Δ = 0
tlist = np.linspace(0, 10*T2_star, 101)

A = zeros((7, 7))
A[0][0], A[1][1], A[0][1], A[1][0] = 0.5, 0.5, 0.5, 0.5

p = Lindblad(ΩR, Ωm, deep, tlist, '0', s, Δ, rho_ini=A, level2='-1')


P0 = [0.5, G_T2_star, 0]  # A, γ, C

params, covariance = opt.curve_fit(exp_decay, tlist, p, p0=P0, maxfev=10000)
A_fit, gamma_fit, C_fit = params

T2_star_fit = 1/(gamma_fit)

# Plotting
plt.figure(figsize=(8, 4))
plt.plot(tlist, p, 'b-')
plt.plot(tlist, exp_decay(tlist, A_fit, gamma_fit, C_fit), 'r--', label=f'Exponential Fit: {A_fit:.2f}exp(-{gamma_fit:.4f}t) + {C_fit:.2f}')
plt.xlabel('Time (мкс)')
plt.ylabel('Population')
plt.title(f'Relaxation of Level |{level}⟩ (T2* = {T2_star_fit:.3f} мкс)')
plt.legend(fontsize=10)
plt.grid(True)
plt.show()

print(f"T2* from fit: {T2_star_fit:.5f} ")
print(f"Theoretical T2*: {T2_star:.3f} мкс")
#print(f"Equilibrium Population: {population_eq:.4f}")

"""## Проверка Раби осцилляции"""

def collaps_operators(s):

  # T1 relaxation (|-1><0|, |0><-1|, |+1><0|, |0><+1|)
  L_T1_1 = create_operator(0, 1, G_T1/3)
  L_T1_2 = create_operator(1, 0, G_T1/3)
  L_T1_3 = create_operator(0, 2, G_T1/3)
  L_T1_4 = create_operator(2, 0, G_T1/3)

  # Optical pumping (|e0><0|, |e-1><-1|, |+1><e+1|)
  L_opt_1 = create_operator(3, 0, G_T_3E * s)
  L_opt_2 = create_operator(4, 1, G_T_3E * s)
  L_opt_3 = create_operator(5, 2, G_T_3E * s)

  # Decay from excited states (|0><e0|, |-1><e-1|, |+1><e+1|)
  L_decay_1 = create_operator(0, 3, G_T_3E)
  L_decay_2 = create_operator(1, 4, G_T_3E * 0.7)
  L_decay_3 = create_operator(2, 5, G_T_3E * 0.7)

  # Decay from |e-1>,|e+1> to |s>
  L_e1_s_1 = create_operator(6, 4, G_T_3E * 0.3)
  L_e1_s_2 = create_operator(6, 5, G_T_3E * 0.3)

  # Decay from |s> to ground states (equal probability)
  L_s_g0 = create_operator(0, 6, G_T_1E * 0.8)
  L_s_gm1 = create_operator(1, 6, G_T_1E * 0.1)
  L_s_gp1 = create_operator(2, 6, G_T_1E * 0.1)

  c_ops = [L_T1_1, L_T1_2, L_T1_3, L_T1_4,
           L_opt_1, L_opt_2, L_opt_3,
           L_decay_1, L_decay_2, L_decay_3,
           L_e1_s_1, L_e1_s_2,
           L_s_g0, L_s_gm1, L_s_gp1]

  return c_ops

#@title find_local_minimum(A) -> list(min1, min2, ...)

def find_local_minimum(A):
    local_minimum = []
    for i in range(len(A)-1):
      if A[i] < A[i - 1] and A[i] < A[i + 1]:
        local_minimum.append(i)

    return local_minimum

level_0 = '0'
level_m1 = '-1'
level_p1 = '+1'

ΩR = 0.5
Ωm = 0
deep = 0
s = 0.
Δ = 0
tlist = linspace(0, 20*ΩR, 101)

p_0 =  Lindblad(ΩR, Ωm, deep, tlist, level_0,  s, Δ)
p_m1 = Lindblad(ΩR, Ωm, deep, tlist, level_m1, s, Δ)
p_p1 = Lindblad(ΩR, Ωm, deep, tlist, level_p1, s, Δ)


population_0 =  Get_equilibrium(level_0, ΩR, s)
population_m1 = Get_equilibrium(level_m1, ΩR, s)
population_p1 = Get_equilibrium(level_p1, ΩR, s)

print(f"Населённость уровня |{level_0}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ",round(population_0, 4))
print(f"Населённость уровня |{level_m1}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ",round(population_m1, 4))
print(f"Населённость уровня |{level_p1}> при параметре насыщения s={s} и частоте Раби ΩR={ΩR} MHz: ",round(population_p1, 4))


plt.figure(figsize=(8, 4))
plt.plot(tlist, p_0, label = f'level = |{level_0}>')
plt.plot(tlist, p_m1, label = f'level = |{level_m1}>')
plt.plot(tlist, p_p1, label = f'level = |{level_p1}>')
plt.xlabel('time, мкс')
plt.ylabel(f'Population')
plt.legend()
plt.grid(True)
plt.show()

print(find_local_minimum(p_0))
start_time, finish_time = find_local_minimum(p_0)[1], find_local_minimum(p_0)[2]
print(f"Частота Раби, оцененная по графику: {1./float(tlist[finish_time] - tlist[start_time])} MHz")
print(f"Частота Раби, заданная в эксперименте: {ΩR} MHz")

"""## Линейный скан частоты СВЧ поля при включенном лазере"""

Sz = zeros((7, 7))
Sz[0][0], Sz[2][2] = 1, -1
Sz = Qobj(Sz)

level = '0'
s = 0.001
Δ_mas = linspace(-2, 2, 1001)
ΩR_mas = [0.001, 0.01, 0.03, 0.1, 0.3]
#ΩR_mas = logspace(-2,0,5)

total_steps = len(Δ_mas) * len(ΩR_mas)
progress_bar = tqdm(total=total_steps, desc="Общий прогресс цикла", position = 0)

plt.figure(figsize=(8, 4))
for ΩR in ΩR_mas:
  populations = []
  for Δ in Δ_mas:
    populations.append(Get_equilibrium(level, ΩR, s, Δ))
    progress_bar.update(1)
  plt.plot(array(Δ_mas), populations, label = f'ΩR ={ΩR} MHz')

progress_bar.close()


plt.xlabel('Detune Δ [MHz]')
plt.ylabel(f'Population at level |{level}>')
plt.legend()
plt.grid(True)
plt.show()

"""# Рассчёт $dS/d\omega$

Смотрим зависимость населённости от времени
"""

#@title Смотрим зависимость населённости от времени
level = '0'

ΩR = 0.5
Ωm = 5 * 1e-3
deep = 0.5
s = 1e-3
Δ = 1
tlist = linspace(0, 1./Ωm * 5, 1001)

occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 3))

# Первый график
ax1.plot(tlist, occupations, label = f'level = |{level}>')
ax1.set_xlabel('time, мкс')
ax1.set_ylabel('Population')
ax1.set_title("full graphic")
ax1.legend()

# Второй график
ax2.plot(tlist[10:], occupations[10:], label = f'level = |{level}>')
ax2.set_xlabel('time, мкс')
ax2.set_title("zoom graphic")
ax2.legend()

plt.grid(True)
plt.tight_layout()
plt.show()

#@title find_local_minimum(A) -> list(min1, min2, ...)

def find_local_minimum(A):
    local_minimum = []
    for i in range(len(A)-1):
      if A[i] < A[i - 1] and A[i] < A[i + 1]:
        local_minimum.append(i)

    return local_minimum

find_local_minimum(occupations)

#@title Посмотрим на дисперсионный контур
level = '0'


ΩR = 0.5 * 1e6/norm
Ωm = 5 * 1e3/norm
s = 1e-2
Δ = 1 * 1e6/norm
tlist, dt= linspace(0, 4./Ωm , 201, retstep=True)

deep = 0.5
#deep_arr = np.array([0.01, 0.05, 0.1, 0.3, 0.5, 0.7, 0.9, ])

Δ_arr = linspace(-4, 4, 25)


total_steps = len(Δ_arr)
progress_bar = tqdm(total=total_steps, desc="Общий прогресс цикла", position = 0)


Signal = []
for Δ in Δ_arr:

  occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ, False)
  #plt.plot(tlist[8:], occupations[8:], label = f"Δ={Δ} MHz ")
  #loc_mins = find_local_minimum(occupations)
  t_start = 8#loc_mins[1]
  normirovka = 1./(tlist[-1] - tlist[t_start])

  x = tlist[t_start:]
  sig_mod = cos(x * Ωm*pi2)
  rho = occupations[t_start:]
  y = sig_mod * rho
  sig = normirovka * sum(y) * dt #cumtrapz(x, y, initial = 0)

  Signal.append(sig)
  progress_bar.update(1)

#plt.plot(tlist[t_start:], 0.5 + 0.1*cos(tlist[t_start:] * Ωm*pi2) )
# plt.legend()
# plt.grid(True)
# plt.show()

progress_bar.close()


plt.figure(figsize=(8, 4))
plt.plot(Δ_arr, Signal, label = f'level = |{level}>')
plt.xlabel('Δ, [MHz]')
plt.ylabel(f'Signal')
plt.legend()
plt.grid(True)
plt.show()
print(Signal)

#@title Построим dSignal/dω
level = '0'


ΩR = 0.01
Ωm = 5*1e-3
s = 1e-2
Δ = 1
tlist, dt= linspace(0, 4./Ωm , 101, retstep=True)

#deep_arr = np.array([ 0.1, 0.5, 0.9, 1, 3, 5])
deep_arr = linspace(0.5, 1.5, 11)

Δ_arr = [-0.2, 0.2]
dΔ = Δ_arr[-1] - Δ_arr[0]
dSignal_dω = []

total_steps = len(Δ_arr) * len(deep_arr)
progress_bar = tqdm(total=total_steps, desc="Общий прогресс цикла", position = 0)

for deep in deep_arr:
  Signal = []
  for Δ in Δ_arr:

    occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s, Δ, False)
    #loc_mins = find_local_minimum(occupations)
    t_start = 10
    normirovka = 1./(tlist[-1] - tlist[t_start])

    x = tlist[t_start:]
    sig_mod = cos(x * Ωm*pi2)
    rho = occupations[t_start:]
    y = sig_mod * rho
    sig = normirovka * sum(y) * dt

    Signal.append(sig)
    progress_bar.update(1)

  dSignal_dω.append((Signal[-1] - Signal[0])/dΔ)

progress_bar.close()

dSignal_dω

print(f"s ={s}, ΩR = {ΩR} MHz, Ωm = {Ωm*1e3} kHz ")

plt.figure(figsize=(8, 4))
plt.plot(deep_arr, dSignal_dω)
plt.xlabel('deep, [MHz]')
plt.ylabel(f'dSignal/dω')
#plt.legend()
plt.grid(True)
#plt.xscale('log')
plt.show()

"""# Рассчёт чувствительности"""

#@title s_parametr(el, P0=P0, n_nv=n_nv_minus, d_opt=d_opt):  ->float(s)

gamma = 28*1e3
sigma_nv = 2.8 * 1e-17 / 1e4       # см^2 -> м^2
c_conc = 1.75 * 1e20 *1e9          # мм^-3 -> м^-3
d_opt = 105 *1e-6                  # мкм -> м
phi = pi/6
h = 6.63 *1e-34                    # Дж * с
c = 3*1e8                          # м/c
E532 = h * c / (532 * 1e-9)
E670 = h * c / (670 * 1e-9)
kollection = 0.15
Gopt = 1./(13 * 1e-9)              #c^-1
n_nv_minus = 0.86 * 1e-6
P0 = 30 *1e-3                      #Вт

k = lambda n_nv: sigma_nv * c_conc * n_nv                   # коэффициент поглощения в алмазе
d = lambda d_opt, x_arg: d_opt + 2 * x_arg * tan(phi)       # диаметр лазерного пучка при распространении
P_beam =lambda P0, x_arg, n_nv: P0 * exp(-x_arg * k(n_nv))  # мощность пучка накачки
density = lambda P0, x_arg, n_nv, d_opt: 4/pi * P_beam(P0, x_arg, n_nv)/d(d_opt, x_arg)**2          # плотность мощности накачки

def s_parametr(el, P0=P0, n_nv=n_nv_minus, d_opt=d_opt):    #параметр насыщения
  s_param = density(P0, el, n_nv, d_opt) * sigma_nv / (E532 * Gopt)
  return s_param

el_mas = np.linspace(0, 1e-3, 101)
y = np.ones(101)*1e-5

plt.plot(el_mas*1e3, s_parametr(el_mas))
plt.plot(el_mas*1e3, y)

plt.grid(True)
plt.xlabel("L, mm")
plt.ylabel("s_parametr")
plt.yscale("log")

level = '0'
ΩR = 0.5
Ωm = 5*1e-3
Δ = 1
deep = 0.7
tlist, dt = linspace(0, 1./Ωm * 40, 1001, retstep=True)
L, dl = np.linspace(0, 0.0002, 10, retstep = 'True')

Δ_arr = [-0.2, 0.2]
dΔ = Δ_arr[-1] - Δ_arr[0]
dSignal_dω = []

total_steps = len(Δ_arr) * len(L)
progress_bar = tqdm(total=total_steps, desc="Общий прогресс цикла", position = 0)

for l in L:
  Signal = []
  for Δ in Δ_arr:

    occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s_parametr(l), Δ, True)

    t_start = 800
    normirovka = 1./(tlist[-1] - tlist[t_start])

    x = tlist[t_start:]
    sig_mod = cos(x * Ωm*pi2)
    rho = occupations[t_start:]
    y = sig_mod * rho
    sig = normirovka * sum(y) * dt

    Signal.append(sig)
    progress_bar.update(1)

  dSignal_dω.append((Signal[-1] - Signal[0])/dΔ)

progress_bar.close()

plt.plot(L, dSignal_dω)

from multiprocessing import Pool
import numpy as np
from tqdm import tqdm


level = '0'
ΩR = 0.5
Ωm = 5*1e-3
Δ = 1
deep = 0.7
tlist, dt = np.linspace(0, 1./Ωm * 40, 1001, retstep=True)
L, dl = np.linspace(0, 0.0004, 20, retstep=True)

Δ_arr = [-0.2, 0.2]
dΔ = Δ_arr[-1] - Δ_arr[0]
dSignal_dω_parallel = []

# Функция для вычисления сигнала для одного набора параметров
def compute_signal(params):
    l, Δ = params
    occupations = Lindblad(ΩR, Ωm, deep, tlist, level, s_parametr(l), Δ, True)

    t_start = 800
    normirovka = 1./(tlist[-1] - tlist[t_start])

    x = tlist[t_start:]
    sig_mod = np.cos(x * Ωm*pi2)
    rho = occupations[t_start:]
    y = sig_mod * rho
    sig = normirovka * sum(y) * dt

    return sig, l, Δ

# Создаем список всех комбинаций параметров
params_list = [(l, Δ) for l in L for Δ in Δ_arr]

# Используем multiprocessing Pool для распараллеливания
with Pool() as pool:
    results = list(tqdm(pool.imap(compute_signal, params_list),
                       total=len(params_list),
                       desc="Вычисление сигналов"))

# Собираем результаты
Signal_dict = {l: [] for l in L}
for sig, l, Δ in results:
    Signal_dict[l].append(sig)

# Вычисляем производную
dSignal_dω_parallel = []
for l in L:
    Signal = Signal_dict[l]
    dSignal_dω_parallel.append((Signal[-1] - Signal[0])/dΔ)

dSdB = array(dSignal_dω_parallel)*gamma/1e6

dBdS = 1./dSdB
chislitel = 0
znamenatel = 0
for i in range(len(L)):
    R = P0*kollection/E670 * exp(-k(n_nv_minus) * L[i]) * dl
    chislitel += dBdS[i] * R


L_noise, dl_noise = np.linspace(0, 0.004, 1000, retstep = "True")
for i in range(len(L_noise)):
    R = P0*kollection/E670 * exp(-k(n_nv_minus) * L_noise[i]) * dl_noise
    znamenatel+=R


nu = sqrt(znamenatel) / chislitel
print("Чувствительность для Fm (L=4мм) = 5кГц равна: ", round(nu*1e9/2.8*1e4, 2), "nT/Hz^0.5")